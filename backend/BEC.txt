============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Api\Controllers\AnalyticsController.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Application.Interfaces;
using Microsoft.AspNetCore.Mvc;

namespace invoice_v1.src.Api.Controllers
{
    // Analytics and insights endpoints
    [ApiController]
    [Route("api/[controller]")]
    public class AnalyticsController : ControllerBase
    {
        private readonly IAnalyticsService _analyticsService;
        private readonly ILogger<AnalyticsController> _logger;

        public AnalyticsController(
            IAnalyticsService analyticsService,
            ILogger<AnalyticsController> logger)
        {
            _analyticsService = analyticsService;
            _logger = logger;
        }

        // Get products sold in a date range
        [HttpGet("products/sales")]
        [ProducesResponseType(typeof(List<ProductSalesDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetProductSales(
            [FromQuery] DateTime startDate,
            [FromQuery] DateTime endDate,
            [FromQuery] string? category = null)
        {
            var results = await _analyticsService.GetProductSalesByDateRangeAsync(
                startDate,
                endDate,
                category);

            return Ok(results);
        }

        // Get trending products
        [HttpGet("products/trending")]
        [ProducesResponseType(typeof(List<ProductTrendDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetTrendingProducts(
            [FromQuery] DateTime startDate,
            [FromQuery] DateTime endDate,
            [FromQuery] int topN = 10)
        {
            var results = await _analyticsService.GetTrendingProductsAsync(
                startDate,
                endDate,
                topN);

            return Ok(results);
        }

        // Get category sales
        [HttpGet("categories/sales")]
        [ProducesResponseType(typeof(List<CategorySalesDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetCategorySales(
            [FromQuery] DateTime startDate,
            [FromQuery] DateTime endDate)
        {
            var results = await _analyticsService.GetCategorySalesAsync(startDate, endDate);
            return Ok(results);
        }

        // Get time-series for a product
        [HttpGet("products/{productId}/timeseries")]
        [ProducesResponseType(typeof(List<ProductTimeSeriesDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetProductTimeSeries(
            string productId,
            [FromQuery] DateTime startDate,
            [FromQuery] DateTime endDate,
            [FromQuery] TimeGranularity granularity = TimeGranularity.Monthly)
        {
            var results = await _analyticsService.GetProductTimeSeriesAsync(
                productId,
                startDate,
                endDate,
                granularity);

            return Ok(results);
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Api\Controllers\CallbackController.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Application.Interfaces;
using invoice_v1.src.Domain.Entities;
using invoice_v1.src.Infrastructure.Data;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System.Text;
using System.Text.Json;

namespace invoice_v1.src.Api.Controllers
{
    [ApiController]
    [Route("api/ai/[controller]")]
    public class CallbackController : ControllerBase
    {
        private readonly IJobService _jobService;
        private readonly IInvoiceService _invoiceService;
        private readonly IHmacValidator _hmacValidator;
        private readonly ApplicationDbContext _context;
        private readonly ILogger<CallbackController> _logger;

        public CallbackController(
            IJobService jobService,
            IInvoiceService invoiceService,
            IHmacValidator hmacValidator,
            ApplicationDbContext context,
            ILogger<CallbackController> logger)
        {
            _jobService = jobService;
            _invoiceService = invoiceService;
            _hmacValidator = hmacValidator;
            _context = context;
            _logger = logger;
        }

        [HttpPost]
        [Consumes("application/json")]
        public async Task<IActionResult> HandleCallback()
        {
            Request.EnableBuffering();

            using var reader = new StreamReader(Request.Body, Encoding.UTF8, leaveOpen: true);
            var requestBody = await reader.ReadToEndAsync();
            Request.Body.Position = 0;

            if (!Request.Headers.TryGetValue("X-Callback-HMAC", out var hmacHeader))
            {
                return Unauthorized(new { error = "Missing X-Callback-HMAC header" });
            }

            if (!_hmacValidator.ValidateHmac(requestBody, hmacHeader!))
            {
                return Unauthorized(new { error = "Invalid HMAC signature" });
            }

            CallbackRequest? request;
            try
            {
                request = JsonSerializer.Deserialize<CallbackRequest>(
                    requestBody,
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            }
            catch (JsonException)
            {
                return BadRequest(new { error = "Invalid JSON format" });
            }

            if (request == null)
            {
                return BadRequest(new { error = "Invalid request payload" });
            }

            var job = await _jobService.GetJobByIdAsync(request.JobId);
            if (job == null)
            {
                return NotFound(new { error = $"Job {request.JobId} not found" });
            }

            switch (request.Status.ToUpperInvariant())
            {
                case "COMPLETED":
                    await HandleCompletedCallbackAsync(request);
                    break;

                case "INVALID":
                    await HandleInvalidCallbackAsync(request);
                    break;

                case "FAILED":
                    await HandleFailedCallbackAsync(request);
                    break;

                default:
                    return BadRequest(new { error = $"Invalid status: {request.Status}" });
            }

            return Ok(new
            {
                success = true,
                jobId = request.JobId,
                status = request.Status
            });
        }

        private async Task HandleCompletedCallbackAsync(CallbackRequest request)
        {
            if (request.Result == null)
                throw new ArgumentException("Result is required for COMPLETED status");

            var strategy = _context.Database.CreateExecutionStrategy();

            await strategy.ExecuteAsync(async () =>
            {
                await using var transaction = await _context.Database.BeginTransactionAsync();

                var invoice = await _invoiceService.CreateOrUpdateInvoiceFromCallbackAsync(
                    request.JobId,
                    request.Result);

                var job = await _context.JobQueues.FindAsync(request.JobId);
                if (job != null)
                {
                    job.Status = "COMPLETED";
                    job.UpdatedAt = DateTime.UtcNow;
                    job.LockedBy = null;
                    job.LockedAt = null;

                    await _context.SaveChangesAsync();
                }

                await transaction.CommitAsync();

                _logger.LogInformation(
                    "Job {JobId} completed. Invoice {InvoiceId} processed",
                    request.JobId,
                    invoice.Id);
            });
        }

        private async Task HandleInvalidCallbackAsync(CallbackRequest request)
        {
            var reasonJson = JsonDocument.Parse(
                JsonSerializer.Serialize(new
                {
                    message = request.Reason ?? "No reason provided"
                })
            );

            await _jobService.MarkInvalidAsync(request.JobId, reasonJson);

            var jobEntity = await _context.JobQueues
                .AsNoTracking()
                .FirstOrDefaultAsync(j => j.Id == request.JobId);

            if (jobEntity?.PayloadJson != null)
            {
                var root = jobEntity.PayloadJson.RootElement;


                var fileId = root.TryGetProperty("fileId", out var fid) ? fid.GetString() : null;
                var fileName = root.TryGetProperty("originalName", out var fn) ? fn.GetString() : null;

                var invalidInvoice = new InvalidInvoice
                {
                    Id = Guid.NewGuid(),
                    FileId = fileId,
                    FileName = fileName,
                    Reason = reasonJson,
                    CreatedAt = DateTime.UtcNow
                };

                _context.InvalidInvoices.Add(invalidInvoice);
                await _context.SaveChangesAsync();
            }
        }

        private async Task HandleFailedCallbackAsync(CallbackRequest request)
        {
            var errorJson = JsonDocument.Parse(
                JsonSerializer.Serialize(new
                {
                    message = request.Reason ?? "Worker reported failure"
                })
            );

            await _jobService.MarkFailedAsync(request.JobId, errorJson);

            _logger.LogError(
                "Job {JobId} marked as FAILED",
                request.JobId);
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Api\Controllers\InvoicesController.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Application.Interfaces;
using Microsoft.AspNetCore.Mvc;

namespace invoice_v1.src.Api.Controllers
{
    // Handles invoice query operations.
    // Provides endpoints for retrieving invoice data and extraction results.
    [ApiController]
    [Route("api/[controller]")]
    public class InvoicesController : ControllerBase
    {
        private readonly IInvoiceService _invoiceService;
        private readonly ILogger<InvoicesController> _logger;

        public InvoicesController(
            IInvoiceService invoiceService,
            ILogger<InvoicesController> logger)
        {
            _invoiceService = invoiceService;
            _logger = logger;
        }

        // Gets an invoice by ID.
        [HttpGet("{id}")]
        [ProducesResponseType(typeof(InvoiceDto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetInvoiceById(Guid id)
        {
            var invoice = await _invoiceService.GetInvoiceByIdAsync(id);
            if (invoice == null)
            {
                return NotFound(new { error = $"Invoice {id} not found" });
            }

            return Ok(invoice);
        }

        // Gets an invoice by Drive file ID.
        [HttpGet("by-file/{fileId}")]
        [ProducesResponseType(typeof(InvoiceDto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetInvoiceByFileId(string fileId)
        {
            var invoice = await _invoiceService.GetInvoiceByFileIdAsync(fileId);
            if (invoice == null)
            {
                return NotFound(new { error = $"No invoice found for file {fileId}" });
            }

            return Ok(invoice);
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Api\Controllers\JobsController.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Application.Interfaces;
using invoice_v1.src.Domain.Enums;
using Microsoft.AspNetCore.Mvc;

namespace invoice_v1.src.Api.Controllers
{
    /// Handles job management operations.
    // Provides endpoints for listing jobs, querying job status, and admin actions.
    [ApiController]
    [Route("api/[controller]")]
    public class JobsController : ControllerBase
    {
        private readonly IJobService _jobService;
        private readonly IConfiguration _configuration;
        private readonly ILogger<JobsController> _logger;

        public JobsController(
            IJobService jobService,
            IConfiguration configuration,
            ILogger<JobsController> logger)
        {
            _jobService = jobService;
            _configuration = configuration;
            _logger = logger;
        }

        // Lists jobs with optional filtering by status.
        [HttpGet]
        [ProducesResponseType(typeof(JobListResponse), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetJobs(
            [FromQuery] string? status = null,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 50)
        {
            JobStatus? jobStatus = null;
            if (!string.IsNullOrWhiteSpace(status))
            {
                if (!Enum.TryParse<JobStatus>(status, true, out var parsedStatus))
                {
                    return BadRequest(new { error = $"Invalid status: {status}" });
                }
                jobStatus = parsedStatus;
            }

            var (jobs, total) = await _jobService.GetJobsAsync(jobStatus, page, pageSize);

            var response = new JobListResponse
            {
                Jobs = jobs,
                Page = page,
                PageSize = pageSize,
                Total = total
            };

            return Ok(response);
        }

        // Gets a specific job by ID.
        [HttpGet("{id}")]
        [ProducesResponseType(typeof(JobDto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetJobById(Guid id)
        {
            var job = await _jobService.GetJobByIdAsync(id);
            if (job == null)
            {
                return NotFound(new { error = $"Job {id} not found" });
            }

            return Ok(job);
        }

        // Requeues a failed job (admin endpoint).
        [HttpPost("{id}/requeue")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status401Unauthorized)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> RequeueJob(Guid id)
        {
            // Validate admin API key
            if (!Request.Headers.TryGetValue("X-Api-Key", out var apiKey))
            {
                _logger.LogWarning("Requeue rejected: Missing X-Api-Key header");
                return Unauthorized(new { error = "Missing X-Api-Key header" });
            }

            var expectedApiKey = _configuration["Security:AdminApiKey"];
            if (string.IsNullOrWhiteSpace(expectedApiKey))
            {
                _logger.LogError("Admin API key not configured");
                return StatusCode(500, new { error = "Server configuration error" });
            }

            if (apiKey != expectedApiKey)
            {
                _logger.LogWarning("Requeue rejected: Invalid API key");
                return Unauthorized(new { error = "Invalid API key" });
            }

            try
            {
                await _jobService.RequeueJobAsync(id);

                _logger.LogInformation("Job {JobId} requeued by admin", id);

                return Ok(new
                {
                    success = true,
                    jobId = id,
                    message = "Job requeued successfully"
                });
            }
            catch (InvalidOperationException ex)
            {
                return NotFound(new { error = ex.Message });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error requeuing job {JobId}", id);
                return StatusCode(500, new { error = "Internal server error" });
            }
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Api\Controllers\LogsController.cs
============================================================
using invoice_v1.src.Infrastructure.Data;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace invoice_v1.src.Api.Controllers
{
    // Handles file change log queries.
    [ApiController]
    [Route("api/[controller]")]
    public class LogsController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public LogsController(ApplicationDbContext context)
        {
            _context = context;
        }

        // Gets paginated file change logs.
        [HttpGet]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<IActionResult> GetLogs(
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 50)
        {
            if (page < 1) page = 1;
            if (pageSize < 1 || pageSize > 100) pageSize = 50;

            var logs = await _context.FileChangeLogs
                .OrderByDescending(l => l.DetectedAt)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            var total = await _context.FileChangeLogs.CountAsync();

            return Ok(new
            {
                logs,
                page,
                pageSize,
                total,
                totalPages = (int)Math.Ceiling(total / (double)pageSize)
            });
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Api\Controllers\ProductsController.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Infrastructure.Data;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace invoice_v1.src.Api.Controllers
{
    // Controller for product catalog operations
    [ApiController]
    [Route("api/[controller]")]
    public class ProductsController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<ProductsController> _logger;

        public ProductsController(
            ApplicationDbContext context,
            ILogger<ProductsController> logger)
        {
            _context = context;
            _logger = logger;
        }

        // Get all products with pagination
        [HttpGet]
        [ProducesResponseType(typeof(ProductListResponse), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetProducts(
            [FromQuery] string? category = null,
            [FromQuery] string? search = null,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 50)
        {
            if (page < 1) page = 1;
            if (pageSize < 1 || pageSize > 100) pageSize = 50;

            var query = _context.Products.AsQueryable();

            // Filter by category
            if (!string.IsNullOrWhiteSpace(category))
            {
                query = query.Where(p => p.Category != null && p.Category.Contains(category));
            }

            // Search by product name or ID
            if (!string.IsNullOrWhiteSpace(search))
            {
                query = query.Where(p =>
                    p.ProductName.Contains(search) ||
                    p.ProductId.Contains(search));
            }

            var total = await query.CountAsync();

            var products = await query
                .OrderByDescending(p => p.TotalRevenue)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .Select(p => new ProductDto
                {
                    Id = p.Id,
                    ProductId = p.ProductId,
                    ProductName = p.ProductName,
                    Category = p.Category,
                    PrimaryCategory = p.PrimaryCategory,
                    SecondaryCategory = p.SecondaryCategory,
                    DefaultUnitRate = p.DefaultUnitRate,
                    TotalQuantitySold = p.TotalQuantitySold,
                    TotalRevenue = p.TotalRevenue,
                    InvoiceCount = p.InvoiceCount,
                    LastSoldDate = p.LastSoldDate,
                    CreatedAt = p.CreatedAt,
                    UpdatedAt = p.UpdatedAt
                })
                .ToListAsync();

            return Ok(new ProductListResponse
            {
                Products = products,
                Total = total,
                Page = page,
                PageSize = pageSize,
                TotalPages = (int)Math.Ceiling((double)total / pageSize)
            });
        }

        // Get product by ID (GUID)
        [HttpGet("{id:guid}")]
        [ProducesResponseType(typeof(ProductDto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetProductById(Guid id)
        {
            var product = await _context.Products
                .Where(p => p.Id == id)
                .Select(p => new ProductDto
                {
                    Id = p.Id,
                    ProductId = p.ProductId,
                    ProductName = p.ProductName,
                    Category = p.Category,
                    PrimaryCategory = p.PrimaryCategory,
                    SecondaryCategory = p.SecondaryCategory,
                    DefaultUnitRate = p.DefaultUnitRate,
                    TotalQuantitySold = p.TotalQuantitySold,
                    TotalRevenue = p.TotalRevenue,
                    InvoiceCount = p.InvoiceCount,
                    LastSoldDate = p.LastSoldDate,
                    CreatedAt = p.CreatedAt,
                    UpdatedAt = p.UpdatedAt
                })
                .FirstOrDefaultAsync();

            if (product == null)
            {
                return NotFound(new { Message = $"Product with ID {id} not found" });
            }

            return Ok(product);
        }

        // Get product by business ProductId
        [HttpGet("by-code/{productId}")]
        [ProducesResponseType(typeof(ProductDto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetProductByProductId(string productId)
        {
            var product = await _context.Products
                .Where(p => p.ProductId == productId)
                .Select(p => new ProductDto
                {
                    Id = p.Id,
                    ProductId = p.ProductId,
                    ProductName = p.ProductName,
                    Category = p.Category,
                    PrimaryCategory = p.PrimaryCategory,
                    SecondaryCategory = p.SecondaryCategory,
                    DefaultUnitRate = p.DefaultUnitRate,
                    TotalQuantitySold = p.TotalQuantitySold,
                    TotalRevenue = p.TotalRevenue,
                    InvoiceCount = p.InvoiceCount,
                    LastSoldDate = p.LastSoldDate,
                    CreatedAt = p.CreatedAt,
                    UpdatedAt = p.UpdatedAt
                })
                .FirstOrDefaultAsync();

            if (product == null)
            {
                return NotFound(new { Message = $"Product with code {productId} not found" });
            }

            return Ok(product);
        }
        // Get list of categories
        [HttpGet("categories")]
        [ProducesResponseType(typeof(List<CategoryDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetCategories()
        {
            var categories = await _context.Products
                .Where(p => p.PrimaryCategory != null)
                .GroupBy(p => p.PrimaryCategory)
                .Select(g => new CategoryDto
                {
                    Category = g.Key!,
                    ProductCount = g.Count(),
                    TotalRevenue = g.Sum(p => p.TotalRevenue)
                })
                .OrderByDescending(c => c.TotalRevenue)
                .ToListAsync();

            return Ok(categories);
        }
    }

    public class CategoryDto
    {
        public string Category { get; set; } = string.Empty;
        public int ProductCount { get; set; }
        public decimal TotalRevenue { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Api\Middleware\ExceptionHandlingMiddleware.cs
============================================================
using System.Net;
using System.Text.Json;

namespace invoice_v1.src.Api.Middleware
{
    /// Global exception handling middleware.
    /// Catches unhandled exceptions and returns structured error responses.
    public class ExceptionHandlingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<ExceptionHandlingMiddleware> _logger;
        private readonly IHostEnvironment _environment;

        public ExceptionHandlingMiddleware(
            RequestDelegate next,
            ILogger<ExceptionHandlingMiddleware> logger,
            IHostEnvironment environment)
        {
            _next = next;
            _logger = logger;
            _environment = environment;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unhandled exception occurred: {Message}", ex.Message);
                await HandleExceptionAsync(context, ex);
            }
        }

        private async Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            context.Response.ContentType = "application/json";

            var response = new ErrorResponse
            {
                Message = "An error occurred processing your request",
                TraceId = context.TraceIdentifier
            };

            switch (exception)
            { 
                case ArgumentNullException:
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    response.Message = exception.Message;
                    break;
                case ArgumentException:
                case InvalidOperationException:
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    response.Message = exception.Message;
                    break;

                case UnauthorizedAccessException:
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    response.Message = "Unauthorized access";
                    break;

                default:
                    context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
                    if (_environment.IsDevelopment())
                    {
                        response.Message = exception.Message;
                        response.Details = exception.StackTrace;
                    }
                    break;
            }

            var json = JsonSerializer.Serialize(response, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });

            await context.Response.WriteAsync(json);
        }

        private class ErrorResponse
        {
            public string Message { get; set; } = string.Empty;
            public string TraceId { get; set; } = string.Empty;
            public string? Details { get; set; }
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\BackgroundServices\JobCreationService.cs
============================================================
using invoice_v1.src.Application.Interfaces;
using invoice_v1.src.Infrastructure.Repositories;

namespace invoice_v1.src.Application.BackgroundServices
{
    // Background service that periodically checks for unprocessed FileChangeLogs
    // and creates corresponding JobQueue entries.
    // This service owns the job creation logic.
    public class JobCreationService : BackgroundService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<JobCreationService> _logger;
        private readonly TimeSpan _interval;
        private const int BatchSize = 50;

        public JobCreationService(
            IServiceProvider serviceProvider,
            IConfiguration configuration,
            ILogger<JobCreationService> logger)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;

            // Read interval from configuration (default: 30 seconds)
            var intervalSeconds = configuration.GetValue<int>("JobCreation:IntervalSeconds", 30);
            _interval = TimeSpan.FromSeconds(intervalSeconds);
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Job Creation Service starting. Interval: {Interval}", _interval);

            // Wait a bit before first run to let the app fully initialize
            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);

            using var timer = new PeriodicTimer(_interval);

            try
            {
                // Run first check immediately
                await ProcessUnprocessedLogsAsync(stoppingToken);

                // Then run on interval
                while (await timer.WaitForNextTickAsync(stoppingToken))
                {
                    try
                    {
                        await ProcessUnprocessedLogsAsync(stoppingToken);
                    }
                    catch (OperationCanceledException)
                    {
                        _logger.LogInformation("Job creation operation cancelled");
                        break;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error during job creation cycle");
                    }
                }
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("Job Creation Service stopping gracefully");
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Job Creation Service encountered a fatal error");
                throw;
            }

            _logger.LogInformation("Job Creation Service stopped");
        }

        private async Task ProcessUnprocessedLogsAsync(CancellationToken cancellationToken)
        {
            using var scope = _serviceProvider.CreateScope();
            var jobRepository = scope.ServiceProvider.GetRequiredService<IJobRepository>();
            var jobService = scope.ServiceProvider.GetRequiredService<IJobService>();

            var unprocessedLogs = await jobRepository.GetUnprocessedFileChangeLogsAsync(BatchSize);

            if (unprocessedLogs.Count == 0)
            {
                _logger.LogDebug("No unprocessed file change logs found");
                return;
            }

            _logger.LogInformation("Processing {Count} unprocessed file change logs", unprocessedLogs.Count);

            var successCount = 0;
            var errorCount = 0;

            foreach (var log in unprocessedLogs)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    break;
                }

                try
                {
                    var job = await jobService.CreateJobFromLogAsync(log);
                    successCount++;

                    _logger.LogInformation(
                        "Created job {JobId} from log {LogId} for file {FileId}",
                        job.Id,
                        log.Id,
                        log.FileId);
                }
                catch (Exception ex)
                {
                    errorCount++;
                    _logger.LogError(
                        ex,
                        "Failed to create job from log {LogId} for file {FileId}",
                        log.Id,
                        log.FileId);
                }
            }

            _logger.LogInformation(
                "Job creation cycle completed. Success: {SuccessCount}, Errors: {ErrorCount}",
                successCount,
                errorCount);
        }

        public override async Task StopAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation("Job Creation Service stopping...");
            await base.StopAsync(cancellationToken);
            _logger.LogInformation("Job Creation Service stopped gracefully");
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\DTOs\AnalyticsDto.cs
============================================================
namespace invoice_v1.src.Application.DTOs
{
    // will help with frontend queries
    public class ProductSalesDto
    {
        public string ProductId { get; set; } = string.Empty;
        public string ProductName { get; set; } = string.Empty;
        public string? Category { get; set; }
        public decimal TotalQuantity { get; set; }
        public decimal TotalRevenue { get; set; }
        public int InvoiceCount { get; set; }
        public decimal AverageUnitRate { get; set; }
    }

    public class ProductTrendDto
    {
        public string ProductId { get; set; } = string.Empty;
        public string ProductName { get; set; } = string.Empty;
        public string? Category { get; set; }
        public decimal TotalQuantity { get; set; }
        public decimal TotalRevenue { get; set; }
        public int InvoiceCount { get; set; }
        public decimal GrowthRate { get; set; }
        public int Rank { get; set; }
    }

    public class CategorySalesDto
    {
        public string Category { get; set; } = string.Empty;
        public int ProductCount { get; set; }
        public decimal TotalQuantity { get; set; }
        public decimal TotalRevenue { get; set; }
        public int InvoiceCount { get; set; }
        public decimal AverageOrderValue { get; set; }
    }

    public class ProductTimeSeriesDto
    {
        public DateTime Period { get; set; }
        public string ProductId { get; set; } = string.Empty;
        public string ProductName { get; set; } = string.Empty;
        public decimal Quantity { get; set; }
        public decimal Revenue { get; set; }
        public int InvoiceCount { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\DTOs\CallbackRequest.cs
============================================================
using System.ComponentModel.DataAnnotations;

namespace invoice_v1.src.Application.DTOs
{
    // Request DTO for worker callback endpoint.
    // Schema defined in contracts/callback_schema.json
    public class CallbackRequest
    {
        [Required(ErrorMessage = "JobId is required")]
        public Guid JobId { get; set; }

        [Required(ErrorMessage = "Status is required")]
        [RegularExpression("^(COMPLETED|INVALID|FAILED)$", ErrorMessage = "Status must be COMPLETED, INVALID, or FAILED")]
        public string Status { get; set; } = string.Empty;
        // Extracted invoice data (for COMPLETED status).
        public object? Result { get; set; }

        // Reason for failure/invalidity (for INVALID/FAILED status).
        [MaxLength(2000)]
        public string? Reason { get; set; }

        [MaxLength(200)]
        public string? WorkerId { get; set; }

        public DateTime? ProcessedAt { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\DTOs\CreateJobRequest.cs
============================================================
using System.ComponentModel.DataAnnotations;

namespace invoice_v1.src.Application.DTOs
{
    // Request DTO for manual job creation (admin endpoint).
    public class CreateJobRequest
    {
        [Required]
        [MaxLength(100)]
        public string FileId { get; set; } = string.Empty;

        [MaxLength(500)]
        public string? FileName { get; set; }

        [MaxLength(200)]
        public string? MimeType { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\DTOs\InvoiceDto.cs
============================================================
namespace invoice_v1.src.Application.DTOs
{
    public class InvoiceDto
    {
        public Guid Id { get; set; }
        public string? InvoiceNumber { get; set; }
        public DateTime? InvoiceDate { get; set; }
        public string? OrderId { get; set; }
        public string? VendorName { get; set; }

        // Bill To
        public string? BillToName { get; set; }

        // Ship To
        public ShipToDto? ShipTo { get; set; }

        public string? ShipMode { get; set; }

        // Financial
        public decimal? Subtotal { get; set; }
        public DiscountDto? Discount { get; set; }
        public decimal? ShippingCost { get; set; }
        public decimal? TotalAmount { get; set; }
        public decimal? BalanceDue { get; set; }
        public string? Currency { get; set; }

        // Additional
        public string? Notes { get; set; }
        public string? Terms { get; set; }

        // File reference
        public string DriveFileId { get; set; } = string.Empty;
        public string? OriginalFileName { get; set; }

        // Extracted data
        public object? ExtractedData { get; set; }

        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }

        public List<InvoiceLineDto>? LineItems { get; set; }
    }
    // Ship To address information
    public class ShipToDto
    {
        public string? City { get; set; }
        public string? State { get; set; }
        public string? Country { get; set; }
    }

    // Discount information
    public class DiscountDto
    {
        public decimal? Percentage { get; set; }
        public decimal? Amount { get; set; }
    }

    // Data transfer object for invoice line items
    public class InvoiceLineDto
    {
        public Guid Id { get; set; }

        // Product reference
        public string ProductId { get; set; } = string.Empty;
        public string? ProductName { get; set; }
        public string? Category { get; set; }

        // Line details
        public decimal? Quantity { get; set; }
        public decimal? UnitRate { get; set; }
        public decimal? Amount { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\DTOs\JobDto.cs
============================================================
namespace invoice_v1.src.Application.DTOs
{
    // Data transfer object for job information.
    public class JobDto
    {
        public Guid Id { get; set; }
        public string JobType { get; set; } = string.Empty;
        public object? Payload { get; set; }
        public string Status { get; set; } = string.Empty;
        public int RetryCount { get; set; }
        public string? LockedBy { get; set; }
        public DateTime? LockedAt { get; set; }
        public DateTime? NextRetryAt { get; set; }
        public string? ErrorMessage { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
    }

    // Paginated response for job listings.
    public class JobListResponse
    {
        public List<JobDto> Jobs { get; set; } = new();
        public int Page { get; set; }
        public int PageSize { get; set; }
        public int Total { get; set; }
        public int TotalPages => (int)Math.Ceiling(Total / (double)PageSize);
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\DTOs\ProductDto.cs
============================================================
namespace invoice_v1.src.Application.DTOs
{
    // Basic Product DTO for CRUD operations and product catalog display
    public class ProductDto
    {
        public Guid Id { get; set; }

        // Business product identifier
        public string ProductId { get; set; } = string.Empty;

        public string ProductName { get; set; } = string.Empty;

        public string? Category { get; set; }

        public string? PrimaryCategory { get; set; }

        public string? SecondaryCategory { get; set; }

        public decimal? DefaultUnitRate { get; set; }

        // Aggregated statistics (for catalog display)
        public decimal TotalQuantitySold { get; set; }
        public decimal TotalRevenue { get; set; }
        public int InvoiceCount { get; set; }
        public DateTime? LastSoldDate { get; set; }

        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
    }

    // Paginated response for product list
    public class ProductListResponse
    {
        public List<ProductDto> Products { get; set; } = new();
        public int Total { get; set; }
        public int Page { get; set; }
        public int PageSize { get; set; }
        public int TotalPages { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\DTOs\RequeueJobRequest.cs
============================================================
using System.ComponentModel.DataAnnotations;

namespace invoice_v1.src.Application.DTOs
{
    // Request DTO for requeuing a failed job.
    public class RequeueJobRequest
    {
        [Required]
        public Guid JobId { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Interfaces\IAnalyticsService.cs
============================================================
using invoice_v1.src.Application.DTOs;

namespace invoice_v1.src.Application.Interfaces
{
    // Service for analytics and insights queries
    public interface IAnalyticsService
    {
        // Get products sold in a date range, optionally filtered by category
        // like "How many Tables were sold from June 2012 to September 2012?"
        Task<List<ProductSalesDto>> GetProductSalesByDateRangeAsync(
            DateTime startDate,
            DateTime endDate,
            string? category = null);
        // Get trending products in a time period
        // like "Which product is most trendy in the past month?"
        Task<List<ProductTrendDto>> GetTrendingProductsAsync(
            DateTime startDate,
            DateTime endDate,
            int topN = 10);

        // Get category-level sales analytics
        Task<List<CategorySalesDto>> GetCategorySalesAsync(
            DateTime startDate,
            DateTime endDate);

        // Get product sales over time (time series)
        Task<List<ProductTimeSeriesDto>> GetProductTimeSeriesAsync(
            string productId,
            DateTime startDate,
            DateTime endDate,
            TimeGranularity granularity = TimeGranularity.Monthly);
    }

    public enum TimeGranularity
    {
        Daily,
        Weekly,
        Monthly,
        Quarterly,
        Yearly
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Interfaces\IHmacValidator.cs
============================================================
namespace invoice_v1.src.Application.Interfaces
{
    // Service interface for HMAC signature validation.
    public interface IHmacValidator
    {
        // Validates the HMAC signature against the request body.
        bool ValidateHmac(string requestBody, string providedHmac);

        // Computes HMAC-SHA256 signature for the given data.
        string ComputeHmac(string data);
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Interfaces\IInvoiceService.cs
============================================================
using invoice_v1.src.Application.DTOs;

namespace invoice_v1.src.Application.Interfaces
{
    // Service interface for invoice operations.
    public interface IInvoiceService
    {
        Task<InvoiceDto> CreateOrUpdateInvoiceFromCallbackAsync(Guid jobId, object result);
        Task<InvoiceDto?> GetInvoiceByIdAsync(Guid id);
        Task<InvoiceDto?> GetInvoiceByFileIdAsync(string fileId);
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Interfaces\IJobService.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Domain.Entities;
using invoice_v1.src.Domain.Enums;
using System.Text.Json;


namespace invoice_v1.src.Application.Interfaces
{
    // Service interface for job management operations.
    public interface IJobService
    {
        Task<JobDto> CreateJobFromLogAsync(FileChangeLog log);
        Task<JobDto?> GetJobByIdAsync(Guid jobId);
        Task<(List<JobDto> Jobs, int Total)> GetJobsAsync(JobStatus? status, int page, int pageSize);
        Task MarkProcessingAsync(Guid jobId, string workerId);
        Task MarkCompletedAsync(Guid jobId, object result);
        Task MarkInvalidAsync(Guid jobId, JsonDocument reason);
        Task MarkFailedAsync(Guid jobId, JsonDocument error);

    Task RequeueJobAsync(Guid jobId);
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Interfaces\IWorkerClient.cs
============================================================
// not needed still did this for best-practices
namespace invoice_v1.src.Application.Interfaces
{
    public interface IWorkerClient
    {
        Task<bool> SendCallbackAsync(Guid jobId, string status, object? result = null, string? reason = null);
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Services\AnalyticsService.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Application.Interfaces;
using invoice_v1.src.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;

namespace invoice_v1.src.Application.Services
{
    // Analytics service for insightful data retrieval
    public class AnalyticsService : IAnalyticsService
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<AnalyticsService> _logger;

        public AnalyticsService(ApplicationDbContext context, ILogger<AnalyticsService> logger)
        {
            _context = context;
            _logger = logger;
        }

        public async Task<List<ProductSalesDto>> GetProductSalesByDateRangeAsync(
            DateTime startDate,
            DateTime endDate,
            string? category = null)
        {
            var query = _context.InvoiceLines
                .Include(l => l.Invoice)
                .Include(l => l.Product)
                .Where(l => l.Invoice.InvoiceDate.HasValue &&
                           l.Invoice.InvoiceDate >= startDate &&
                           l.Invoice.InvoiceDate <= endDate);

            if (!string.IsNullOrWhiteSpace(category))
            {
                query = query.Where(l => l.Category != null && l.Category.Contains(category));
            }

            var results = await query
                .GroupBy(l => new
                {
                    l.ProductId,
                    l.ProductName,
                    l.Category
                })
                .Select(g => new ProductSalesDto
                {
                    ProductId = g.Key.ProductId,
                    ProductName = g.Key.ProductName,
                    Category = g.Key.Category,
                    TotalQuantity = g.Sum(l => l.Quantity),
                    TotalRevenue = g.Sum(l => l.Amount),
                    InvoiceCount = g.Select(l => l.InvoiceId).Distinct().Count(),
                    AverageUnitRate = g.Average(l => l.UnitRate)
                })
                .OrderByDescending(p => p.TotalQuantity)
                .ToListAsync();

            _logger.LogInformation(
                "ProductSalesByDateRange: {StartDate} to {EndDate}, Category: {Category}, Results: {Count}",
                startDate.ToShortDateString(),
                endDate.ToShortDateString(),
                category ?? "All",
                results.Count);

            return results;
        }

        public async Task<List<ProductTrendDto>> GetTrendingProductsAsync(
            DateTime startDate,
            DateTime endDate,
            int topN = 10)
        {
            var results = await _context.InvoiceLines
                .Include(l => l.Invoice)
                .Where(l => l.Invoice.InvoiceDate.HasValue &&
                           l.Invoice.InvoiceDate >= startDate &&
                           l.Invoice.InvoiceDate <= endDate)
                .GroupBy(l => new
                {
                    l.ProductId,
                    l.ProductName,
                    l.Category
                })
                .Select(g => new ProductTrendDto
                {
                    ProductId = g.Key.ProductId,
                    ProductName = g.Key.ProductName,
                    Category = g.Key.Category,
                    TotalQuantity = g.Sum(l => l.Quantity),
                    TotalRevenue = g.Sum(l => l.Amount),
                    InvoiceCount = g.Count(),
                    GrowthRate = 0 // Can be computed by comparing to previous period
                })
                .OrderByDescending(p => p.TotalQuantity)
                .Take(topN)
                .ToListAsync();

            // Assign ranks
            for (int i = 0; i < results.Count; i++)
            {
                results[i].Rank = i + 1;
            }

            _logger.LogInformation(
                "TrendingProducts: {StartDate} to {EndDate}, Top {TopN}, Found: {Count}",
                startDate.ToShortDateString(),
                endDate.ToShortDateString(),
                topN,
                results.Count);

            return results;
        }

        // Get sales by category
        public async Task<List<CategorySalesDto>> GetCategorySalesAsync(
            DateTime startDate,
            DateTime endDate)
        {
            var results = await _context.InvoiceLines
                .Include(l => l.Invoice)
                .Where(l => l.Invoice.InvoiceDate.HasValue &&
                           l.Invoice.InvoiceDate >= startDate &&
                           l.Invoice.InvoiceDate <= endDate &&
                           l.Category != null)
                .GroupBy(l => l.Category)
                .Select(g => new CategorySalesDto
                {
                    Category = g.Key!,
                    ProductCount = g.Select(l => l.ProductId).Distinct().Count(),
                    TotalQuantity = g.Sum(l => l.Quantity),
                    TotalRevenue = g.Sum(l => l.Amount),
                    InvoiceCount = g.Select(l => l.InvoiceId).Distinct().Count(),
                    AverageOrderValue = g.Average(l => l.Amount)
                })
                .OrderByDescending(c => c.TotalRevenue)
                .ToListAsync();

            return results;
        }

        // Get time-series data for a specific product
        public async Task<List<ProductTimeSeriesDto>> GetProductTimeSeriesAsync(
            string productId,
            DateTime startDate,
            DateTime endDate,
            TimeGranularity granularity = TimeGranularity.Monthly)
        {
            var lineItems = await _context.InvoiceLines
                .Include(l => l.Invoice)
                .Where(l => l.ProductId == productId &&
                           l.Invoice.InvoiceDate.HasValue &&
                           l.Invoice.InvoiceDate >= startDate &&
                           l.Invoice.InvoiceDate <= endDate)
                .Select(l => new
                {
                    l.ProductId,
                    l.ProductName,
                    l.Quantity,
                    l.Amount,
                    InvoiceDate = l.Invoice.InvoiceDate!.Value
                })
                .ToListAsync();

            var grouped = lineItems
                .GroupBy(l => TruncateDate(l.InvoiceDate, granularity))
                .Select(g => new ProductTimeSeriesDto
                {
                    Period = g.Key,
                    ProductId = g.First().ProductId,
                    ProductName = g.First().ProductName,
                    Quantity = g.Sum(l => l.Quantity),
                    Revenue = g.Sum(l => l.Amount),
                    InvoiceCount = g.Count()
                })
                .OrderBy(p => p.Period)
                .ToList();

            return grouped;
        }

        private DateTime TruncateDate(DateTime date, TimeGranularity granularity)
        {
            return granularity switch
            {
                TimeGranularity.Daily => date.Date,
                TimeGranularity.Weekly => date.Date.AddDays(-(int)date.DayOfWeek),
                TimeGranularity.Monthly => new DateTime(date.Year, date.Month, 1),
                TimeGranularity.Quarterly => new DateTime(date.Year, ((date.Month - 1) / 3) * 3 + 1, 1),
                TimeGranularity.Yearly => new DateTime(date.Year, 1, 1),
                _ => date.Date
            };
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Services\HmacValidator.cs
============================================================
using invoice_v1.src.Application.Interfaces;
using System.Security.Cryptography;
using System.Text;

namespace invoice_v1.src.Application.Services
{
    /// <summary>
    /// Implements HMAC-SHA256 signature validation for secure API callbacks.
    /// Used to verify that callback requests originate from authorized workers.
    /// </summary>
    public class HmacValidator : IHmacValidator
    {
        private readonly string _secret;
        private readonly ILogger<HmacValidator> _logger;

        public HmacValidator(IConfiguration configuration, ILogger<HmacValidator> logger)
        {
            _secret = configuration["Security:CallbackSecret"]
                ?? throw new InvalidOperationException(
                    "Security:CallbackSecret is not configured. Set AI_CALLBACK_SECRET environment variable.");
            _logger = logger;
        }

        public bool ValidateHmac(string requestBody, string providedHmac)
        {
            if (string.IsNullOrWhiteSpace(requestBody))
            {
                _logger.LogWarning("HMAC validation failed: empty request body");
                return false;
            }

            if (string.IsNullOrWhiteSpace(providedHmac))
            {
                _logger.LogWarning("HMAC validation failed: no HMAC provided");
                return false;
            }

            try
            {
                var computedHmac = ComputeHmac(requestBody);
                var isValid = computedHmac.Equals(providedHmac, StringComparison.OrdinalIgnoreCase);

                if (!isValid)
                {
                    _logger.LogWarning(
                        "HMAC validation failed. Expected: {ExpectedHmac}, Got: {ProvidedHmac}",
                        computedHmac.Substring(0, Math.Min(8, computedHmac.Length)) + "...",
                        providedHmac.Substring(0, Math.Min(8, providedHmac.Length)) + "...");
                }
                else
                {
                    _logger.LogDebug("HMAC validation successful");
                }

                return isValid;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during HMAC validation");
                return false;
            }
        }

        public string ComputeHmac(string data)
        {
            using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(_secret));
            var hash = hmac.ComputeHash(Encoding.UTF8.GetBytes(data));
            return Convert.ToHexString(hash).ToLowerInvariant();
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Services\InvoiceService.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Application.Interfaces;
using invoice_v1.src.Domain.Entities;
using invoice_v1.src.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;
using System.Text.Json;

namespace invoice_v1.src.Application.Services
{
    public class InvoiceService : IInvoiceService
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<InvoiceService> _logger;

        public InvoiceService(ApplicationDbContext context, ILogger<InvoiceService> logger)
        {
            _context = context;
            _logger = logger;
        }

        public async Task<InvoiceDto> CreateOrUpdateInvoiceFromCallbackAsync(Guid jobId, object result)
        {
            var resultJson = JsonSerializer.Serialize(result);
            var extractedData = JsonSerializer.Deserialize<JsonElement>(resultJson);

            //  VALIDATE CRITICAL FIELDS
            ValidateCriticalFields(extractedData);

            //  GET JOB AND FILE INFO 
            var job = await _context.JobQueues.FindAsync(jobId);
            if (job == null)
            {
                throw new InvalidOperationException($"Job {jobId} not found");
            }

            if (job.PayloadJson == null)
            {
                throw new InvalidOperationException("Job payload is missing");
            }

            var payload = job.PayloadJson.RootElement;

            var fileId = payload.GetProperty("fileId").GetString()
                ?? throw new InvalidOperationException("FileId not found in job payload");
            var fileName = GetStringProperty(payload, "originalName");

            // FIND OR CREATE INVOICE 
            var existingInvoice = await _context.Invoices
                .Include(i => i.LineItems)
                .FirstOrDefaultAsync(i => i.DriveFileId == fileId);

            Invoice invoice;
            if (existingInvoice != null)
            {
                invoice = existingInvoice;
                invoice.UpdatedAt = DateTime.UtcNow;
                _logger.LogInformation("Updating existing invoice {InvoiceId}", invoice.Id);

                // Remove old line items
                _context.InvoiceLines.RemoveRange(existingInvoice.LineItems);
                invoice.LineItems.Clear();
            }
            else
            {
                invoice = new Invoice
                {
                    Id = Guid.NewGuid(),
                    DriveFileId = fileId,
                    OriginalFileName = fileName,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };
                _context.Invoices.Add(invoice);
                _logger.LogInformation("Creating new invoice {InvoiceId}", invoice.Id);
            }

            // MAP INVOICE HEADER FIELDS (WITH NULL SAFETY)

            invoice.InvoiceNumber = GetStringProperty(extractedData, "InvoiceNumber");
            invoice.OrderId = GetStringProperty(extractedData, "OrderId");
            invoice.VendorName = GetStringProperty(extractedData, "VendorName");
            invoice.ShipMode = GetStringProperty(extractedData, "ShipMode");
            invoice.Currency = GetStringProperty(extractedData, "Currency") ?? "USD";  // Default to USD
            invoice.Notes = GetStringProperty(extractedData, "Notes");
            invoice.Terms = GetStringProperty(extractedData, "Terms");

            // Parse invoice date
            invoice.InvoiceDate = GetDateTimeProperty(extractedData, "InvoiceDate");

            // ===== PARSE BILLTO OBJECT =====
            if (extractedData.TryGetProperty("BillTo", out var billToElement)
                && billToElement.ValueKind == JsonValueKind.Object)
            {
                invoice.BillToName = GetStringProperty(billToElement, "Name");
            }
            else
            {
                invoice.BillToName = null;
            }

            //  PARSE SHIPTO OBJECT 
            if (extractedData.TryGetProperty("ShipTo", out var shipToElement)
                && shipToElement.ValueKind == JsonValueKind.Object)
            {
                invoice.ShipToCity = GetStringProperty(shipToElement, "City");
                invoice.ShipToState = GetStringProperty(shipToElement, "State");
                invoice.ShipToCountry = GetStringProperty(shipToElement, "Country");
            }
            else
            {
                invoice.ShipToCity = null;
                invoice.ShipToState = null;
                invoice.ShipToCountry = null;
            }

            //  PARSE FINANCIAL FIELDS (ALL NULLABLE) 
            invoice.Subtotal = GetDecimalProperty(extractedData, "Subtotal");
            invoice.ShippingCost = GetDecimalProperty(extractedData, "ShippingCost");
            invoice.TotalAmount = GetDecimalProperty(extractedData, "TotalAmount");
            invoice.BalanceDue = GetDecimalProperty(extractedData, "BalanceDue");

            //  PARSE DISCOUNT OBJECT (SPECIAL CASE)
            if (extractedData.TryGetProperty("Discount", out var discountElement)
                && discountElement.ValueKind == JsonValueKind.Object)
            {
                invoice.DiscountPercentage = GetDecimalProperty(discountElement, "Percentage");
                invoice.DiscountAmount = GetDecimalProperty(discountElement, "Amount");
            }
            else
            {
                // Discount is null or missing
                invoice.DiscountPercentage = null;
                invoice.DiscountAmount = null;
            }

            // Store full extracted JSON
            invoice.ExtractedDataJson = JsonDocument.Parse(resultJson);


            //  PROCESS LINE ITEMS 
            if (!extractedData.TryGetProperty("LineItems", out var lineItemsElement)
                || lineItemsElement.ValueKind != JsonValueKind.Array)
            {
                throw new InvalidOperationException("LineItems array is required");
            }

            var lineItemsArray = lineItemsElement.EnumerateArray().ToList();
            if (lineItemsArray.Count == 0)
            {
                throw new InvalidOperationException("Invoice must have at least one line item");
            }

            // Track which products we've already counted for this invoice
            var processedProducts = new HashSet<Guid>();

            foreach (var lineElement in lineItemsArray)
            {
                var productId = GetStringProperty(lineElement, "ProductId");
                if (string.IsNullOrWhiteSpace(productId))
                {
                    _logger.LogWarning("Skipping line item with missing ProductId");
                    continue;
                }

                var productName = GetStringProperty(lineElement, "ProductName") ?? "Unknown";
                var category = GetStringProperty(lineElement, "Category");
                var quantity = GetDecimalProperty(lineElement, "Quantity") ?? 0;
                var unitRate = GetDecimalProperty(lineElement, "UnitRate") ?? 0;
                var amount = GetDecimalProperty(lineElement, "Amount") ?? 0;

                // Validate critical line item fields
                if (quantity <= 0)
                {
                    _logger.LogWarning("Skipping line item {ProductId} with invalid quantity: {Quantity}",
                        productId, quantity);
                    continue;
                }

                // Find or create product WITHOUT calling SaveChanges
                var product = await FindOrCreateProductNoSaveAsync(
                    productId,
                    productName,
                    category,
                    unitRate
                );

                // Create invoice line
                var line = new InvoiceLine
                {
                    Id = Guid.NewGuid(),
                    InvoiceId = invoice.Id,
                    ProductGuid = product.Id,
                    ProductId = productId,
                    ProductName = productName,
                    Category = category,
                    Quantity = quantity,
                    UnitRate = unitRate,
                    Amount = amount,
                    CreatedAt = DateTime.UtcNow
                };

                invoice.LineItems.Add(line);

                //  UPDATE PRODUCT STATISTICS 
                product.TotalQuantitySold += quantity;
                product.TotalRevenue += amount;

                if (!processedProducts.Contains(product.Id))
                {
                    product.InvoiceCount++;
                    processedProducts.Add(product.Id);
                }

                // Update last sold date
                if (invoice.InvoiceDate.HasValue)
                {
                    if (!product.LastSoldDate.HasValue
                        || invoice.InvoiceDate.Value > product.LastSoldDate.Value)
                    {
                        product.LastSoldDate = invoice.InvoiceDate.Value;
                    }
                }

                product.UpdatedAt = DateTime.UtcNow;
            }

            // Validate at least one valid line item was processed
            if (invoice.LineItems.Count == 0)
            {
                throw new InvalidOperationException(
                    "No valid line items found. All line items were skipped due to missing or invalid data.");
            }

            // SAVE EVERYTHING ATOMICALLY 
            await _context.SaveChangesAsync();

            _logger.LogInformation(
                "Invoice {InvoiceId} ({InvoiceNumber}) saved successfully with {LineCount} line items",
                invoice.Id,
                invoice.InvoiceNumber ?? "N/A",
                invoice.LineItems.Count);

            return await MapToDtoAsync(invoice);
        }

        // Validates that critical fields are present and valid.
        private void ValidateCriticalFields(JsonElement extractedData)
        {
            var errors = new List<string>();

            // Critical Field 1: InvoiceNumber
            var invoiceNumber = GetStringProperty(extractedData, "InvoiceNumber");
            if (string.IsNullOrWhiteSpace(invoiceNumber))
            {
                errors.Add("InvoiceNumber is required");
            }

            // Critical Field 2: TotalAmount
            var totalAmount = GetDecimalProperty(extractedData, "TotalAmount");
            if (!totalAmount.HasValue || totalAmount.Value <= 0)
            {
                errors.Add("TotalAmount is required and must be greater than 0");
            }

            // Critical Field 3: LineItems array must exist
            if (!extractedData.TryGetProperty("LineItems", out var lineItems)
                || lineItems.ValueKind != JsonValueKind.Array)
            {
                errors.Add("LineItems array is required");
            }
            else if (lineItems.GetArrayLength() == 0)
            {
                errors.Add("LineItems array must contain at least one item");
            }

            if (errors.Any())
            {
                var errorMessage = "Critical validation failed: " + string.Join("; ", errors);
                _logger.LogError(errorMessage);
                throw new InvalidOperationException(errorMessage);
            }
        }

        public async Task<InvoiceDto?> GetInvoiceByIdAsync(Guid id)
        {
            var invoice = await _context.Invoices
                .Include(i => i.LineItems)
                    .ThenInclude(l => l.Product)
                .AsNoTracking()
                .FirstOrDefaultAsync(i => i.Id == id);

            return invoice != null ? await MapToDtoAsync(invoice) : null;
        }

        public async Task<InvoiceDto?> GetInvoiceByFileIdAsync(string fileId)
        {
            var invoice = await _context.Invoices
                .Include(i => i.LineItems)
                    .ThenInclude(l => l.Product)
                .AsNoTracking()
                .FirstOrDefaultAsync(i => i.DriveFileId == fileId);

            return invoice != null ? await MapToDtoAsync(invoice) : null;
        }

        // Find existing product or create new one WITHOUT calling SaveChanges.
        private async Task<Product> FindOrCreateProductNoSaveAsync(
            string productId,
            string productName,
            string? category,
            decimal? unitRate)
        {
            var product = await _context.Products
                .FirstOrDefaultAsync(p => p.ProductId == productId);

            if (product == null)
            {
                // Parse category into primary and secondary
                string? primaryCategory = null;
                string? secondaryCategory = null;

                if (!string.IsNullOrWhiteSpace(category))
                {
                    var parts = category.Split(',', StringSplitOptions.TrimEntries);
                    if (parts.Length > 0) primaryCategory = parts[0];
                    if (parts.Length > 1) secondaryCategory = parts[1];
                }

                product = new Product
                {
                    Id = Guid.NewGuid(),
                    ProductId = productId,
                    ProductName = productName,
                    Category = category,
                    PrimaryCategory = primaryCategory,
                    SecondaryCategory = secondaryCategory,
                    DefaultUnitRate = unitRate,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };

                _context.Products.Add(product);

                _logger.LogInformation(
                    "Created new product {ProductId}: {ProductName} ({Category})",
                    productId,
                    productName,
                    category ?? "N/A");
            }
            else
            {
                // Update product name/category if changed
                if (product.ProductName != productName || product.Category != category)
                {
                    product.ProductName = productName;
                    product.Category = category;

                    // Re-parse category
                    if (!string.IsNullOrWhiteSpace(category))
                    {
                        var parts = category.Split(',', StringSplitOptions.TrimEntries);
                        product.PrimaryCategory = parts.Length > 0 ? parts[0] : null;
                        product.SecondaryCategory = parts.Length > 1 ? parts[1] : null;
                    }
                    else
                    {
                        product.PrimaryCategory = null;
                        product.SecondaryCategory = null;
                    }

                    product.UpdatedAt = DateTime.UtcNow;
                }
            }

            return product;
        }

        private async Task<InvoiceDto> MapToDtoAsync(Invoice invoice)
        {
            object? extractedData = null;

            if (invoice.ExtractedDataJson != null)
            {
                extractedData = JsonSerializer.Deserialize<object>(
                    invoice.ExtractedDataJson.RootElement.GetRawText()
                );
            }


            return new InvoiceDto
            {
                Id = invoice.Id,
                InvoiceNumber = invoice.InvoiceNumber,
                InvoiceDate = invoice.InvoiceDate,
                OrderId = invoice.OrderId,
                VendorName = invoice.VendorName,
                BillToName = invoice.BillToName,
                ShipTo = new ShipToDto
                {
                    City = invoice.ShipToCity,
                    State = invoice.ShipToState,
                    Country = invoice.ShipToCountry
                },
                ShipMode = invoice.ShipMode,
                Subtotal = invoice.Subtotal,
                Discount = new DiscountDto
                {
                    Percentage = invoice.DiscountPercentage,
                    Amount = invoice.DiscountAmount
                },
                ShippingCost = invoice.ShippingCost,
                TotalAmount = invoice.TotalAmount,
                BalanceDue = invoice.BalanceDue,
                Currency = invoice.Currency,
                Notes = invoice.Notes,
                Terms = invoice.Terms,
                DriveFileId = invoice.DriveFileId,
                OriginalFileName = invoice.OriginalFileName,
                ExtractedData = extractedData,
                CreatedAt = invoice.CreatedAt,
                UpdatedAt = invoice.UpdatedAt,
                LineItems = invoice.LineItems.Select(l => new InvoiceLineDto
                {
                    Id = l.Id,
                    ProductName = l.ProductName,
                    Category = l.Category,
                    ProductId = l.ProductId,
                    Quantity = l.Quantity,
                    UnitRate = l.UnitRate,
                    Amount = l.Amount
                }).ToList()
            };
        }


        // Safely extracts a string property from JSON.
        private string? GetStringProperty(JsonElement element, string propertyName)
        {
            if (!element.TryGetProperty(propertyName, out var prop))
                return null;  // Property doesn't exist

            if (prop.ValueKind == JsonValueKind.Null)
                return null;

            if (prop.ValueKind == JsonValueKind.String)
                return prop.GetString();

            // Log unexpected type for debugging
            _logger.LogDebug(
                "Property {PropertyName} has unexpected type {ValueKind}, expected String or Null",
                propertyName,
                prop.ValueKind);

            return null;
        }


        // Returns null if property doesn't exist, is null, or cannot be parsed.
        private decimal? GetDecimalProperty(JsonElement element, string propertyName)
        {
            if (!element.TryGetProperty(propertyName, out var prop))
                return null;  // Property doesn't exist

            if (prop.ValueKind == JsonValueKind.Null)
                return null;

            if (prop.ValueKind == JsonValueKind.Number)
            {
                try
                {
                    return prop.GetDecimal();
                }
                catch (FormatException)
                {
                    // Number is too large for decimal, try double
                    try
                    {
                        return (decimal)prop.GetDouble();
                    }
                    catch
                    {
                        _logger.LogWarning(
                            "Failed to parse {PropertyName} as decimal (value out of range)",
                            propertyName);
                        return null;
                    }
                }
            }

            if (prop.ValueKind == JsonValueKind.String)
            {
                var str = prop.GetString();
                if (!string.IsNullOrWhiteSpace(str) && decimal.TryParse(str, out var value))
                    return value;
            }

            _logger.LogDebug(
                "Property {PropertyName} has unexpected type {ValueKind}, expected Number or Null",
                propertyName,
                prop.ValueKind);

            return null;
        }

        // DateTime property from JSON.
        private DateTime? GetDateTimeProperty(JsonElement element, string propertyName)
        {
            if (!element.TryGetProperty(propertyName, out var prop))
                return null;

            if (prop.ValueKind == JsonValueKind.Null)
                return null;

            if (prop.ValueKind == JsonValueKind.String)
            {
                var str = prop.GetString();
                if (!string.IsNullOrWhiteSpace(str) && DateTime.TryParse(str, out var value))
                    return value;

                _logger.LogWarning(
                    "Failed to parse {PropertyName} as DateTime: {Value}",
                    propertyName,
                    str);
            }

            return null;
        }

        private int? GetIntProperty(JsonElement element, string propertyName)
        {
            if (!element.TryGetProperty(propertyName, out var prop))
                return null;

            if (prop.ValueKind == JsonValueKind.Null)
                return null;

            if (prop.ValueKind == JsonValueKind.Number)
            {
                try
                {
                    return prop.GetInt32();
                }
                catch (FormatException)
                {
                    try
                    {
                        return (int)prop.GetDouble();
                    }
                    catch
                    {
                        return null;
                    }
                }
            }

            if (prop.ValueKind == JsonValueKind.String)
            {
                var str = prop.GetString();
                if (int.TryParse(str, out var value))
                    return value;
            }

            return null;
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Application\Services\JobService.cs
============================================================
using invoice_v1.src.Application.DTOs;
using invoice_v1.src.Application.Interfaces;
using invoice_v1.src.Domain.Entities;
using invoice_v1.src.Domain.Enums;
using invoice_v1.src.Infrastructure.Repositories;
using System.Text.Json;

namespace invoice_v1.src.Application.Services
{
    // Implements job management business logic.
    public class JobService : IJobService
    {
        private readonly IJobRepository _jobRepository;
        private readonly ILogger<JobService> _logger;
        private const int MaxRetries = 3;

        public JobService(IJobRepository jobRepository, ILogger<JobService> logger)
        {
            _jobRepository = jobRepository;
            _logger = logger;
        }

        public async Task<JobDto> CreateJobFromLogAsync(FileChangeLog log)
        {
            if (string.IsNullOrWhiteSpace(log.FileId))
            {
                throw new ArgumentException("FileId cannot be empty", nameof(log));
            }

            // Create structured payload conforming to job_payload_schema.json
            var payload = new
            {
                fileId = log.FileId,
                originalName = log.FileName,
                mimeType = log.MimeType,
                fileSize = log.FileSize,
                uploader = log.ModifiedBy,
                schemaVersion = "1.0",
                idempotencyKey = $"{log.FileId}_{log.DetectedAt:yyyyMMddHHmmss}",
                detectedAt = log.DetectedAt
            };

            var job = new JobQueue
            {
                Id = Guid.NewGuid(),
                JobType = nameof(JobType.INVOICE_EXTRACTION),
                PayloadJson = JsonDocument.Parse(JsonSerializer.Serialize(payload)),
                Status = nameof(JobStatus.PENDING),
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            var created = await _jobRepository.CreateJobAsync(job);
            await _jobRepository.MarkFileChangeLogAsProcessedAsync(log.Id);

            _logger.LogInformation(
                "Created job {JobId} for file {FileId} ({FileName})",
                created.Id,
                log.FileId,
                log.FileName);

            return MapToDto(created);
        }

        public async Task<JobDto?> GetJobByIdAsync(Guid jobId)
        {
            var job = await _jobRepository.GetByIdAsync(jobId);
            return job != null ? MapToDto(job) : null;
        }

        public async Task<(List<JobDto> Jobs, int Total)> GetJobsAsync(
            JobStatus? status,
            int page,
            int pageSize)
        {
            if (page < 1) page = 1;
            if (pageSize < 1 || pageSize > 100) pageSize = 50;

            var skip = (page - 1) * pageSize;
            var jobs = await _jobRepository.GetJobsAsync(status, skip, pageSize);
            var total = await _jobRepository.GetJobCountAsync(status);

            return (jobs.Select(MapToDto).ToList(), total);
        }

        public async Task MarkProcessingAsync(Guid jobId, string workerId)
        {
            var job = await _jobRepository.GetByIdAsync(jobId);
            if (job == null)
            {
                throw new InvalidOperationException($"Job {jobId} not found");
            }

            if (job.Status != nameof(JobStatus.PENDING))
            {
                throw new InvalidOperationException(
                    $"Job {jobId} cannot be marked as PROCESSING. Current status: {job.Status}");
            }

            job.Status = nameof(JobStatus.PROCESSING);
            job.LockedBy = workerId;
            job.LockedAt = DateTime.UtcNow;

            await _jobRepository.UpdateJobAsync(job);

            _logger.LogInformation(
                "Job {JobId} marked as PROCESSING by worker {WorkerId}",
                jobId,
                workerId);
        }

        public async Task MarkCompletedAsync(Guid jobId, object result)
        {
            var job = await _jobRepository.GetByIdAsync(jobId);
            if (job == null)
            {
                throw new InvalidOperationException($"Job {jobId} not found");
            }

            job.Status = nameof(JobStatus.COMPLETED);
            job.ErrorMessage = null;
            job.UpdatedAt = DateTime.UtcNow;

            await _jobRepository.UpdateJobAsync(job);

            _logger.LogInformation("Job {JobId} marked as COMPLETED", jobId);
        }

        public async Task MarkInvalidAsync(Guid jobId, JsonDocument reason)
        {
            var job = await _jobRepository.GetByIdAsync(jobId)
                ?? throw new InvalidOperationException($"Job {jobId} not found");

            job.Status = nameof(JobStatus.INVALID);
            job.ErrorMessage = reason;
            job.UpdatedAt = DateTime.UtcNow;

            await _jobRepository.UpdateJobAsync(job);
        }


        public async Task MarkFailedAsync(Guid jobId, JsonDocument error)
        {
            var job = await _jobRepository.GetByIdAsync(jobId)
                ?? throw new InvalidOperationException($"Job {jobId} not found");

            job.ErrorMessage = error;
            job.RetryCount++;

            // Exponential backoff for retries
            if (job.RetryCount < MaxRetries)
            {
                //Change status to PENDING (was FAILED)
                job.Status = nameof(JobStatus.PENDING);

                // Release lock so worker can claim it
                job.LockedBy = null;
                job.LockedAt = null;

                var backoffMinutes = Math.Pow(2, job.RetryCount);
                job.NextRetryAt = DateTime.UtcNow.AddMinutes(backoffMinutes);

                _logger.LogWarning(
                    "Job {JobId} scheduled for retry {RetryCount}/{MaxRetries}. Next retry at {NextRetryAt}",
                    jobId,
                    job.RetryCount,
                    MaxRetries,
                    job.NextRetryAt);
            }
            else
            {
                //Only set to FAILED permanently after max retries
                job.Status = nameof(JobStatus.FAILED);
                job.LockedBy = null;
                job.LockedAt = null;

                _logger.LogError(
                    "Job {JobId} marked as FAILED permanently after {RetryCount} retries",
                    jobId,
                    job.RetryCount);
            }

            job.UpdatedAt = DateTime.UtcNow;
            await _jobRepository.UpdateJobAsync(job);
        }


        public async Task RequeueJobAsync(Guid jobId)
        {
            var job = await _jobRepository.GetByIdAsync(jobId);
            if (job == null)
            {
                throw new InvalidOperationException($"Job {jobId} not found");
            }

            job.Status = nameof(JobStatus.PENDING);
            job.LockedBy = null;
            job.LockedAt = null;
            job.NextRetryAt = null;
            job.ErrorMessage = null;
            job.RetryCount = 0;
            job.UpdatedAt = DateTime.UtcNow;

            await _jobRepository.UpdateJobAsync(job);

            _logger.LogInformation("Job {JobId} requeued by admin", jobId);
        }

        private static JobDto MapToDto(JobQueue job)
        {
            object? payload = null;
            try
            {
                payload = JsonSerializer.Deserialize<object>(
                    job.PayloadJson.RootElement.GetRawText()
                );

            }
            catch
            {
                payload = job.PayloadJson;
            }

            return new JobDto
            {
                Id = job.Id,
                JobType = job.JobType,
                Payload = payload,
                Status = job.Status,
                RetryCount = job.RetryCount,
                LockedBy = job.LockedBy,
                LockedAt = job.LockedAt,
                NextRetryAt = job.NextRetryAt,
                ErrorMessage = job.ErrorMessage != null
                ? job.ErrorMessage.RootElement.GetRawText()
                : null,
                CreatedAt = job.CreatedAt,
                UpdatedAt = job.UpdatedAt
            };
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Entities\FileChangeLog.cs
============================================================
using System.ComponentModel.DataAnnotations;

namespace invoice_v1.src.Domain.Entities
{
    public class FileChangeLog
    {
        [Key]
        public int Id { get; set; }

        [MaxLength(500)]
        public string? FileName { get; set; }

        [MaxLength(100)]
        public string? FileId { get; set; }

        [MaxLength(50)]
        public string? ChangeType { get; set; }

        [Required]
        public DateTime DetectedAt { get; set; } // store as UTC

        [MaxLength(200)]
        public string? MimeType { get; set; }

        public long? FileSize { get; set; }

        [MaxLength(200)]
        public string? ModifiedBy { get; set; }

        public DateTime? GoogleDriveModifiedTime { get; set; }

        public bool Processed { get; set; } = false;

        public DateTime? ProcessedAt { get; set; }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Entities\InvalidInvoice.cs
============================================================
using System;
using System.ComponentModel.DataAnnotations;
using System.Text.Json;

namespace invoice_v1.src.Domain.Entities
{
    public class InvalidInvoice
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();

        [MaxLength(500)]
        public string? FileName { get; set; }

        [MaxLength(100)]
        public string? FileId { get; set; }

        /// <summary>
        /// Structured reason why the invoice was invalid
        /// (validation errors, OCR issues, parsing failures, etc.)
        /// Stored as jsonb in PostgreSQL.
        /// </summary>
        [Required]
        public JsonDocument Reason { get; set; } = JsonDocument.Parse("{}");

        [Required]
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Entities\Invoice.cs
============================================================
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Text.Json;

namespace invoice_v1.src.Domain.Entities
{
    public class Invoice
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();

        [MaxLength(100)]
        public string? InvoiceNumber { get; set; }

        public DateTime? InvoiceDate { get; set; }

        [MaxLength(100)]
        public string? OrderId { get; set; }

        // Vendor/Seller information
        [MaxLength(200)]
        public string? VendorName { get; set; }

        // Bill To (Customer)
        [MaxLength(200)]
        public string? BillToName { get; set; }

        // Ship To Address
        [MaxLength(200)]
        public string? ShipToCity { get; set; }

        [MaxLength(100)]
        public string? ShipToState { get; set; }

        [MaxLength(100)]
        public string? ShipToCountry { get; set; }

        [MaxLength(50)]
        public string? ShipMode { get; set; }

        // Financial Details
        public decimal? Subtotal { get; set; }
        public decimal? DiscountPercentage { get; set; }
        public decimal? DiscountAmount { get; set; }
        public decimal? ShippingCost { get; set; }
        public decimal? TotalAmount { get; set; }
        public decimal? BalanceDue { get; set; }

        [MaxLength(10)]
        public string? Currency { get; set; }

        // Notes and Terms (simple text)
        public string? Notes { get; set; }
        public string? Terms { get; set; }

        // Drive file reference
        [Required]
        [MaxLength(100)]
        public string DriveFileId { get; set; } = string.Empty;

        [MaxLength(500)]
        public string? OriginalFileName { get; set; }

        /// <summary>
        /// Raw extracted / OCR / ML data for the invoice.
        /// Stored as jsonb in PostgreSQL.
        /// </summary>
        public JsonDocument? ExtractedDataJson { get; set; }

        [Required]
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        [Required]
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        public ICollection<InvoiceLine> LineItems { get; set; } = new List<InvoiceLine>();
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Entities\InvoiceLine.cs
============================================================
using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace invoice_v1.src.Domain.Entities
{
    public class InvoiceLine
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();

        [Required]
        public Guid InvoiceId { get; set; }

        [ForeignKey(nameof(InvoiceId))]
        public Invoice Invoice { get; set; } = null!;

        [Required]
        public Guid ProductGuid { get; set; }

        [ForeignKey(nameof(ProductGuid))]
        public Product Product { get; set; } = null!;

        [Required]
        [MaxLength(100)]
        public string ProductId { get; set; } = string.Empty;

        [Required]
        [MaxLength(500)]
        public string ProductName { get; set; } = string.Empty;

        [MaxLength(200)]
        public string? Category { get; set; }

        [Required]
        public decimal Quantity { get; set; }

        [Required]
        public decimal UnitRate { get; set; }

        [Required]
        public decimal Amount { get; set; }

        [Required]
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Entities\JobQueue.cs
============================================================
using System;
using System.ComponentModel.DataAnnotations;
using System.Text.Json;

namespace invoice_v1.src.Domain.Entities
{
    /// <summary>
    /// Represents a job in the processing queue.
    /// Jobs are created by the backend from FileChangeLogs and claimed by workers.
    /// </summary>
    public class JobQueue
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();

        [Required]
        [MaxLength(50)]
        public string JobType { get; set; } = nameof(Enums.JobType.INVOICE_EXTRACTION);

        /// <summary>
        /// JSON payload containing fileId, originalName, mimeType, etc.
        /// Stored as jsonb in PostgreSQL.
        /// </summary>
        [Required]
        public JsonDocument PayloadJson { get; set; } = JsonDocument.Parse("{}");

        [Required]
        [MaxLength(20)]
        public string Status { get; set; } = nameof(Enums.JobStatus.PENDING);

        public int RetryCount { get; set; } = 0;

        [MaxLength(200)]
        public string? LockedBy { get; set; }

        public DateTime? LockedAt { get; set; }

        public DateTime? NextRetryAt { get; set; }

        /// <summary>
        /// Structured error information (exception, stack trace, worker id, etc.)
        /// Stored as jsonb.
        /// </summary>
        public JsonDocument? ErrorMessage { get; set; }

        [Required]
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        [Required]
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Entities\Product.cs
============================================================
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;

namespace invoice_v1.src.Domain.Entities
{
    public class Product
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();

        [Required]
        [MaxLength(100)]
        public string ProductId { get; set; } = string.Empty;

        [Required]
        [MaxLength(500)]
        public string ProductName { get; set; } = string.Empty;

        [MaxLength(200)]
        public string? Category { get; set; }

        [MaxLength(100)]
        public string? PrimaryCategory { get; set; }

        [MaxLength(100)]
        public string? SecondaryCategory { get; set; }

        public decimal? DefaultUnitRate { get; set; }

        public decimal TotalQuantitySold { get; set; } = 0;

        public decimal TotalRevenue { get; set; } = 0;

        public int InvoiceCount { get; set; } = 0;

        public DateTime? LastSoldDate { get; set; }

        [Required]
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        [Required]
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        public ICollection<InvoiceLine> InvoiceLines { get; set; } = new List<InvoiceLine>();
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Enums\JobStatus.cs
============================================================
namespace invoice_v1.src.Domain.Enums
{
    public enum JobStatus
    {
        PENDING,
        PROCESSING,
        COMPLETED,
        INVALID,
        FAILED
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Domain\Enums\JobType.cs
============================================================
namespace invoice_v1.src.Domain.Enums
{
    public enum JobType
    {
        INVOICE_EXTRACTION
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Infrastructure\Data\ApplicationDbContext.cs
============================================================
using invoice_v1.src.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace invoice_v1.src.Infrastructure.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<FileChangeLog> FileChangeLogs => Set<FileChangeLog>();
        public DbSet<JobQueue> JobQueues => Set<JobQueue>();
        public DbSet<Product> Products => Set<Product>();
        public DbSet<Invoice> Invoices => Set<Invoice>();
        public DbSet<InvoiceLine> InvoiceLines => Set<InvoiceLine>();
        public DbSet<InvalidInvoice> InvalidInvoices => Set<InvalidInvoice>();

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            ConfigureFileChangeLog(modelBuilder);
            ConfigureJobQueue(modelBuilder);
            ConfigureProduct(modelBuilder);
            ConfigureInvoice(modelBuilder);
            ConfigureInvoiceLine(modelBuilder);
            ConfigureInvalidInvoice(modelBuilder);
        }

        // -------------------------
        // FileChangeLog
        // -------------------------
        private static void ConfigureFileChangeLog(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<FileChangeLog>(entity =>
            {
                entity.ToTable("file_change_logs");

                entity.HasKey(e => e.Id);

                entity.Property(e => e.DetectedAt).HasColumnType("timestamptz");
                entity.Property(e => e.GoogleDriveModifiedTime).HasColumnType("timestamptz");
                entity.Property(e => e.ProcessedAt).HasColumnType("timestamptz");

                entity.HasIndex(e => new { e.Processed, e.DetectedAt })
                      .HasDatabaseName("ix_file_change_logs_processed_detected_at");

                entity.HasIndex(e => e.FileId)
                      .HasDatabaseName("ix_file_change_logs_file_id");

                entity.HasIndex(e => e.ChangeType)
                      .HasDatabaseName("ix_file_change_logs_change_type");
            });
        }

        // -------------------------
        // JobQueue
        // -------------------------
        private static void ConfigureJobQueue(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<JobQueue>(entity =>
            {
                entity.ToTable("job_queues");

                entity.HasKey(e => e.Id);

                entity.Property(e => e.PayloadJson).HasColumnType("jsonb");
                entity.Property(e => e.ErrorMessage).HasColumnType("jsonb");

                entity.Property(e => e.CreatedAt).HasColumnType("timestamptz");
                entity.Property(e => e.UpdatedAt).HasColumnType("timestamptz");
                entity.Property(e => e.NextRetryAt).HasColumnType("timestamptz");
                entity.Property(e => e.LockedAt).HasColumnType("timestamptz");

                entity.HasIndex(e => new { e.Status, e.NextRetryAt })
                      .HasDatabaseName("ix_job_queues_status_next_retry_at");

                entity.HasIndex(e => new { e.Status, e.LockedAt })
                      .HasDatabaseName("ix_job_queues_status_locked_at");

                entity.HasIndex(e => e.CreatedAt)
                      .HasDatabaseName("ix_job_queues_created_at");

                // GIN index added via migration SQL
                entity.HasIndex(e => e.PayloadJson)
                      .HasDatabaseName("ix_job_queues_payload_json");
            });
        }

        // -------------------------
        // Product
        // -------------------------
        private static void ConfigureProduct(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Product>(entity =>
            {
                entity.ToTable("products");

                entity.HasKey(e => e.Id);

                entity.Property(e => e.DefaultUnitRate).HasColumnType("numeric(18,2)");
                entity.Property(e => e.TotalQuantitySold).HasColumnType("numeric(18,4)");
                entity.Property(e => e.TotalRevenue).HasColumnType("numeric(18,2)");

                entity.Property(e => e.LastSoldDate).HasColumnType("timestamptz");
                entity.Property(e => e.CreatedAt).HasColumnType("timestamptz");
                entity.Property(e => e.UpdatedAt).HasColumnType("timestamptz");

                entity.HasIndex(e => e.ProductId)
                      .IsUnique()
                      .HasDatabaseName("ix_products_product_id_unique");

                entity.HasIndex(e => e.PrimaryCategory)
                      .HasDatabaseName("ix_products_primary_category");

                entity.HasIndex(e => e.Category)
                      .HasDatabaseName("ix_products_category");

                entity.HasIndex(e => e.TotalRevenue)
                      .HasDatabaseName("ix_products_total_revenue");

                entity.HasIndex(e => e.LastSoldDate)
                      .HasDatabaseName("ix_products_last_sold_date");
            });
        }

        // -------------------------
        // Invoice
        // -------------------------
        private static void ConfigureInvoice(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Invoice>(entity =>
            {
                entity.ToTable("invoices");

                entity.HasKey(e => e.Id);

                entity.Property(e => e.InvoiceDate).HasColumnType("timestamptz");
                entity.Property(e => e.CreatedAt).HasColumnType("timestamptz");
                entity.Property(e => e.UpdatedAt).HasColumnType("timestamptz");

                entity.Property(e => e.Subtotal).HasColumnType("numeric(18,2)");
                entity.Property(e => e.DiscountPercentage).HasColumnType("numeric(18,2)");
                entity.Property(e => e.DiscountAmount).HasColumnType("numeric(18,2)");
                entity.Property(e => e.ShippingCost).HasColumnType("numeric(18,2)");
                entity.Property(e => e.TotalAmount).HasColumnType("numeric(18,2)");
                entity.Property(e => e.BalanceDue).HasColumnType("numeric(18,2)");

                entity.Property(e => e.ExtractedDataJson).HasColumnType("jsonb");

                entity.HasIndex(e => e.DriveFileId)
                      .IsUnique()
                      .HasDatabaseName("ix_invoices_drive_file_id_unique");

                entity.HasIndex(e => e.InvoiceDate)
                      .HasDatabaseName("ix_invoices_invoice_date");

                entity.HasIndex(e => new { e.InvoiceDate, e.TotalAmount })
                      .HasDatabaseName("ix_invoices_date_amount");
            });
        }

        // -------------------------
        // InvoiceLine
        // -------------------------
        private static void ConfigureInvoiceLine(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<InvoiceLine>(entity =>
            {
                entity.ToTable("invoice_lines");

                entity.HasKey(e => e.Id);

                entity.Property(e => e.Quantity).HasColumnType("numeric(18,4)");
                entity.Property(e => e.UnitRate).HasColumnType("numeric(18,2)");
                entity.Property(e => e.Amount).HasColumnType("numeric(18,2)");
                entity.Property(e => e.CreatedAt).HasColumnType("timestamptz");

                entity.HasOne(e => e.Invoice)
                      .WithMany(i => i.LineItems)
                      .HasForeignKey(e => e.InvoiceId)
                      .OnDelete(DeleteBehavior.Cascade);

                entity.HasOne(e => e.Product)
                      .WithMany(p => p.InvoiceLines)
                      .HasForeignKey(e => e.ProductGuid)
                      .OnDelete(DeleteBehavior.Restrict);

                entity.HasIndex(e => e.ProductGuid)
                      .HasDatabaseName("ix_invoice_lines_product_guid");

                entity.HasIndex(e => new { e.ProductGuid, e.InvoiceId })
                      .HasDatabaseName("ix_invoice_lines_product_invoice");
            });
        }

        // -------------------------
        // InvalidInvoice
        // -------------------------
        private static void ConfigureInvalidInvoice(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<InvalidInvoice>(entity =>
            {
                entity.ToTable("invalid_invoices");

                entity.HasKey(e => e.Id);

                entity.Property(e => e.Id)
                      .HasDefaultValueSql("gen_random_uuid()");

                entity.Property(e => e.Reason).HasColumnType("jsonb");
                entity.Property(e => e.CreatedAt).HasColumnType("timestamptz");

                entity.HasIndex(e => e.FileId)
                      .HasDatabaseName("ix_invalid_invoices_file_id");

                // GIN index via migration SQL
                entity.HasIndex(e => e.Reason)
                      .HasDatabaseName("ix_invalid_invoices_reason");
            });
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Infrastructure\Data\ApplicationDBContextFactory.cs
============================================================
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;

namespace invoice_v1.src.Infrastructure.Data
{
    public class ApplicationDbContextFactory
        : IDesignTimeDbContextFactory<ApplicationDbContext>
    {
        public ApplicationDbContext CreateDbContext(string[] args)
        {
            // Build configuration manually
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: false)
                .AddJsonFile("appsettings.Development.json", optional: true)
                .AddEnvironmentVariables()
                .Build();

            var connectionString = configuration.GetConnectionString("DefaultConnection");

            if (string.IsNullOrWhiteSpace(connectionString))
            {
                throw new InvalidOperationException(
                    "Connection string 'DefaultConnection' not found.");
            }

            var optionsBuilder = new DbContextOptionsBuilder<ApplicationDbContext>();
            optionsBuilder.UseNpgsql(connectionString);

            return new ApplicationDbContext(optionsBuilder.Options);
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Infrastructure\Repositories\IJobRepository.cs
============================================================
using invoice_v1.src.Domain.Entities;
using invoice_v1.src.Domain.Enums;

namespace invoice_v1.src.Infrastructure.Repositories
{
    public interface IJobRepository
    {
        Task<JobQueue?> GetByIdAsync(Guid id);
        Task<List<JobQueue>> GetJobsAsync(JobStatus? status, int skip, int take);
        Task<int> GetJobCountAsync(JobStatus? status);
        Task<JobQueue> CreateJobAsync(JobQueue job);
        Task UpdateJobAsync(JobQueue job);
        Task<List<FileChangeLog>> GetUnprocessedFileChangeLogsAsync(int limit);
        Task MarkFileChangeLogAsProcessedAsync(int logId);
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Infrastructure\Repositories\JobRepository.cs
============================================================
using invoice_v1.src.Domain.Entities;
using invoice_v1.src.Domain.Enums;
using invoice_v1.src.Infrastructure.Data;
using invoice_v1.src.Infrastructure.Repositories;
using Microsoft.EntityFrameworkCore;

namespace invoice_v1.src.Infrastructure.Repositories
{
    public class JobRepository : IJobRepository
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<JobRepository> _logger;

        public JobRepository(ApplicationDbContext context, ILogger<JobRepository> logger)
        {
            _context = context;
            _logger = logger;
        }

        public async Task<JobQueue?> GetByIdAsync(Guid id)
        {
            return await _context.JobQueues
                .AsNoTracking()
                .FirstOrDefaultAsync(j => j.Id == id);
        }

        public async Task<List<JobQueue>> GetJobsAsync(JobStatus? status, int skip, int take)
        {
            var query = _context.JobQueues.AsNoTracking().AsQueryable();

            if (status.HasValue)
            {
                var statusString = status.Value.ToString();
                query = query.Where(j => j.Status == statusString);
            }

            return await query
                .OrderByDescending(j => j.CreatedAt)
                .Skip(skip)
                .Take(take)
                .ToListAsync();
        }

        public async Task<int> GetJobCountAsync(JobStatus? status)
        {
            var query = _context.JobQueues.AsQueryable();

            if (status.HasValue)
            {
                var statusString = status.Value.ToString();
                query = query.Where(j => j.Status == statusString);
            }

            return await query.CountAsync();
        }

        public async Task<JobQueue> CreateJobAsync(JobQueue job)
        {
            _context.JobQueues.Add(job);
            await _context.SaveChangesAsync();

            _logger.LogInformation("Created job {JobId} of type {JobType}", job.Id, job.JobType);

            return job;
        }

        public async Task UpdateJobAsync(JobQueue job)
        {
            job.UpdatedAt = DateTime.UtcNow;
            _context.JobQueues.Update(job);
            await _context.SaveChangesAsync();

            _logger.LogDebug("Updated job {JobId} to status {Status}", job.Id, job.Status);
        }

        public async Task<List<FileChangeLog>> GetUnprocessedFileChangeLogsAsync(int limit)
        {
            return await _context.FileChangeLogs
                .Where(log => !log.Processed &&
                             (log.ChangeType == "Upload" || log.ChangeType == "Modified") &&
                             log.FileId != null)
                .OrderBy(log => log.DetectedAt)
                .Take(limit)
                .ToListAsync();
        }

        public async Task MarkFileChangeLogAsProcessedAsync(int logId)
        {
            var log = await _context.FileChangeLogs.FindAsync(logId);
            if (log != null)
            {
                log.Processed = true;
                log.ProcessedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();

                _logger.LogDebug("Marked FileChangeLog {LogId} as processed", logId);
            }
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Services\DriveMonitoringService.cs
============================================================
using invoice_v1.src.Domain.Entities;
using invoice_v1.src.Infrastructure.Data;
using invoice_v1.src.Services;
using Microsoft.EntityFrameworkCore;
using System.Collections.Concurrent;

namespace invoice_v1.src.Services
{
    // Background service that monitors Google Drive folder for file changes.

    public class DriveMonitoringService : BackgroundService
    {
        private readonly ILogger<DriveMonitoringService> _logger;
        private readonly IServiceProvider _serviceProvider;
        private readonly TimeSpan _interval = TimeSpan.FromHours(1);

        private readonly ConcurrentDictionary<string, DateTime> _lastSeenFiles = new();

        private readonly HashSet<string> _allowedMimeTypes = new()
        {
            "application/pdf",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "image/jpeg",
            "image/png",
            "text/csv",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        };
        private static DateTime ToUtc(DateTime dt)
        {
            return dt.Kind switch
            {
                DateTimeKind.Utc => dt,
                DateTimeKind.Local => dt.ToUniversalTime(),
                DateTimeKind.Unspecified => DateTime.SpecifyKind(dt, DateTimeKind.Utc),
                _ => dt
            };
        }


        public DriveMonitoringService(
            ILogger<DriveMonitoringService> logger,
            IServiceProvider serviceProvider)
        {
            _logger = logger;
            _serviceProvider = serviceProvider;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Drive Monitoring Service is starting");

            try
            {
                await HydrateDictionaryFromDatabase(stoppingToken);

                using var timer = new PeriodicTimer(_interval);

                await DoWork(stoppingToken);

                while (await timer.WaitForNextTickAsync(stoppingToken))
                {
                    try
                    {
                        await DoWork(stoppingToken);
                    }
                    catch (OperationCanceledException)
                    {
                        _logger.LogInformation("Drive monitoring operation was cancelled");
                        break;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error during monitoring tick");
                    }
                }
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("Drive Monitoring Service is stopping gracefully");
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Drive Monitoring Service encountered a fatal error");
                throw;
            }

            _logger.LogInformation("Drive Monitoring Service has stopped");
        }

        private async Task HydrateDictionaryFromDatabase(CancellationToken cancellationToken)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();

                var lastSeenFiles = await dbContext.FileChangeLogs
                    .Where(log => log.FileId != null &&
                                  log.GoogleDriveModifiedTime != null &&
                                  (log.ChangeType == "Upload" || log.ChangeType == "Modified"))
                    .GroupBy(log => log.FileId)
                    .Select(group => new
                    {
                        FileId = group.Key,
                        ModifiedTime = group
                            .OrderByDescending(log => log.GoogleDriveModifiedTime)
                            .Select(log => log.GoogleDriveModifiedTime!.Value)
                            .FirstOrDefault()
                    })
                    .ToListAsync(cancellationToken);

                foreach (var file in lastSeenFiles.Where(f => f.FileId != null))
                {
                    _lastSeenFiles.TryAdd(file.FileId!, ToUtc(file.ModifiedTime));
                }

                _logger.LogInformation(
                    "Hydrated {Count} files from database into tracking dictionary",
                    _lastSeenFiles.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error hydrating dictionary from database");
            }
        }

        private async Task DoWork(CancellationToken cancellationToken)
        {
            _logger.LogInformation("Drive Monitoring check at: {Time}", DateTimeOffset.Now);

            try
            {
                using var scope = _serviceProvider.CreateScope();
                var driveService = scope.ServiceProvider.GetRequiredService<IGoogleDriveService>();
                var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
                var config = scope.ServiceProvider.GetRequiredService<IConfiguration>();

                var folderId = config["GoogleDrive:SharedFolderId"];

                if (string.IsNullOrEmpty(folderId))
                {
                    _logger.LogWarning("Shared folder ID not configured");
                    return;
                }

                var files = await driveService.ListFilesInFolderAsync(folderId, cancellationToken);

                if (files.Count == 0)
                {
                    _logger.LogInformation("No files found in folder");
                    await DetectDeletedFiles(new Dictionary<string, DateTime>(), dbContext, cancellationToken);
                    return;
                }

                var allCurrentFiles = files
                    .Where(f => f.ModifiedTime.HasValue)
                    .ToDictionary(f => f.Id, f => ToUtc(f.ModifiedTime!.Value));


                var logsToAdd = new List<FileChangeLog>();

                foreach (var file in files)
                {
                    bool isAllowed = !string.IsNullOrEmpty(file.MimeType) &&
                                    _allowedMimeTypes.Contains(file.MimeType);

                    if (!isAllowed)
                    {
                        _logger.LogWarning(
                            "File {FileName} with MIME type {MimeType} is not allowed and will be skipped",
                            file.Name,
                            file.MimeType);

                        _lastSeenFiles.TryRemove(file.Id, out _);
                        continue;
                    }

                    var fileModifiedTime = file.ModifiedTime.HasValue
                        ? ToUtc(file.ModifiedTime.Value)
                        : DateTime.MinValue;


                    if (!_lastSeenFiles.ContainsKey(file.Id))
                    {
                        logsToAdd.Add(new FileChangeLog
                        {
                            FileName = file.Name,
                            FileId = file.Id,
                            ChangeType = "Upload",
                            DetectedAt = DateTime.UtcNow,
                            MimeType = file.MimeType,
                            FileSize = file.Size,
                            ModifiedBy = file.Owners?.FirstOrDefault()?.DisplayName ?? "Unknown",
                            GoogleDriveModifiedTime = fileModifiedTime
                        });

                        _logger.LogInformation("New file detected: {FileName}", file.Name);
                    }
                    else if (_lastSeenFiles.TryGetValue(file.Id, out var lastSeenTime) &&
                             lastSeenTime < fileModifiedTime)
                    {
                        logsToAdd.Add(new FileChangeLog
                        {
                            FileName = file.Name,
                            FileId = file.Id,
                            ChangeType = "Modified",
                            DetectedAt = DateTime.UtcNow,
                            MimeType = file.MimeType,
                            FileSize = file.Size,
                            ModifiedBy = file.Owners?.FirstOrDefault()?.DisplayName ?? "Unknown",
                            GoogleDriveModifiedTime = fileModifiedTime
                        });

                        _logger.LogInformation("File modified: {FileName}", file.Name);
                    }
                }

                if (logsToAdd.Any())
                {
                    dbContext.FileChangeLogs.AddRange(logsToAdd);
                }

                await DetectDeletedFiles(allCurrentFiles, dbContext, cancellationToken);

                await dbContext.SaveChangesAsync(cancellationToken);

                var allowedCurrentFiles = files
                    .Where(f => f.MimeType != null &&
                               _allowedMimeTypes.Contains(f.MimeType) &&
                               f.ModifiedTime.HasValue)
                    .ToDictionary(f => f.Id, f => ToUtc(f.ModifiedTime!.Value));

                foreach (var kvp in allowedCurrentFiles)
                {
                    _lastSeenFiles.AddOrUpdate(kvp.Key, kvp.Value, (key, oldValue) => kvp.Value);
                }

                var deletedFileIds = _lastSeenFiles.Keys
                    .Except(allCurrentFiles.Keys)
                    .ToList();

                foreach (var fileId in deletedFileIds)
                {
                    _lastSeenFiles.TryRemove(fileId, out _);
                }

                _logger.LogInformation(
                    "Monitoring check completed. Tracked {Count} files, {Deleted} deleted",
                    _lastSeenFiles.Count,
                    deletedFileIds.Count);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during monitoring check");
                throw;
            }
        }

        private async Task DetectDeletedFiles(
            Dictionary<string, DateTime> currentFiles,
            ApplicationDbContext dbContext,
            CancellationToken cancellationToken)
        {
            var deletedFileIds = _lastSeenFiles.Keys
                .Where(oldFileId => !currentFiles.ContainsKey(oldFileId))
                .ToList();

            foreach (var oldFileId in deletedFileIds)
            {
                var changeLog = new FileChangeLog
                {
                    FileId = oldFileId,
                    ChangeType = "Deleted",
                    DetectedAt = DateTime.UtcNow
                };

                dbContext.FileChangeLogs.Add(changeLog);
                _logger.LogInformation("File deleted: {FileId}", oldFileId);
            }
        }

        public override async Task StopAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation("Drive Monitoring Service is stopping...");
            await base.StopAsync(cancellationToken);
            _logger.LogInformation("Drive Monitoring Service stopped gracefully");
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Services\GoogleDriveService.cs
============================================================
using Google.Apis.Auth.OAuth2;
using Google.Apis.Drive.v3;
using Google.Apis.Services;
using invoice_v1.src.Services;

namespace invoice_v1.src.Services
{
    // Google Drive service implementation using service account authentication.
    public class GoogleDriveService : IGoogleDriveService
    {
        private readonly DriveService? _driveService;
        private readonly ILogger<GoogleDriveService> _logger;

        public GoogleDriveService(IConfiguration configuration, ILogger<GoogleDriveService> logger)
        {
            _logger = logger;

            var keyPath = configuration["GoogleDrive:ServiceAccountKeyPath"];

            if (!string.IsNullOrEmpty(keyPath) && File.Exists(keyPath))
            {
                try
                {
                    var credential = GoogleCredential
                        .FromFile(keyPath)
                        .CreateScoped(DriveService.ScopeConstants.DriveReadonly);

                    _driveService = new DriveService(new BaseClientService.Initializer()
                    {
                        HttpClientInitializer = credential,
                        ApplicationName = "Invoice Processing System V2"
                    });

                    _logger.LogInformation("Google Drive service initialized successfully");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to initialize Google Drive service");
                    _driveService = null;
                }
            }
            else
            {
                _logger.LogWarning(
                    "Service account key not found at: {Path}. Drive monitoring disabled.",
                    keyPath);
            }
        }

        public async Task<List<Google.Apis.Drive.v3.Data.File>> ListFilesInFolderAsync(
            string folderId,
            CancellationToken cancellationToken = default)
        {
            if (_driveService == null)
            {
                _logger.LogWarning("Drive service not initialized");
                return new List<Google.Apis.Drive.v3.Data.File>();
            }

            try
            {
                var request = _driveService.Files.List();
                request.Q = $"'{folderId}' in parents and trashed=false";
                request.Fields = "files(id, name, mimeType, size, modifiedTime, createdTime, owners)";
                request.PageSize = 1000;

                var result = await request.ExecuteAsync(cancellationToken);
                _logger.LogInformation(
                    "Listed {Count} files from folder {FolderId}",
                    result.Files.Count,
                    folderId);

                return result.Files.ToList();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error listing files from folder {FolderId}", folderId);
                return new List<Google.Apis.Drive.v3.Data.File>();
            }
        }
    }
}



============================================================
FILE: C:\Users\adithya.jeyaramsanka\OneDrive - AVEVA Solutions Limited\Dev\invoice-poc\backend\src\Services\IGoogleDriveService.cs
============================================================
namespace invoice_v1.src.Services
{
    // Interface for Google Drive operations.
    public interface IGoogleDriveService
    {
        Task<List<Google.Apis.Drive.v3.Data.File>> ListFilesInFolderAsync(
            string folderId,
            CancellationToken cancellationToken = default);
    }
}



